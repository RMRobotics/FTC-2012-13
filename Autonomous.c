#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  HTServo)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Motor,  motorA,          outrigger,     tmotorNXT, PIDControl, reversed, encoder)
#pragma config(Motor,  motorB,          outrigger2,    tmotorNXT, PIDControl, reversed, encoder)
#pragma config(Motor,  motorC,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  mtr_S1_C1_1,     right,         tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     left,          tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     back,          tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     front,         tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_1,     lift,          tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_2,     arm,           tmotorTetrix, PIDControl, encoder)
#pragma config(Servo,  srvo_S1_C4_1,    wrist,                tServoStandard)
#pragma config(Servo,  srvo_S1_C4_2,    tineHook1,            tServoStandard)
#pragma config(Servo,  srvo_S1_C4_3,    tineHook2,            tServoStandard)
#pragma config(Servo,  srvo_S1_C4_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                           Autonomous Mode Code Template
//
// This file contains a template for simplified creation of an autonomous program for an TETRIX robot
// competition.
//
// You need to customize two functions with code unique to your specific robot.
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

#define ARMSPEED 2
#define DRIVESPEED 100
#define LIFTSPEED 100
#define WRISTSPEED .1
#define FORWARD 0		                   //move left motor cw, right motor ccw
#define BACKWARD 4		                 //move left motor ccw, right motor cw
#define	LEFT 6 	                       //move front motor ccw, back motor cw
#define	RIGHT 2 	                     //move front motor cw, back motor ccw
#define	DIAGONALFOWARDLEFT 7           //move front motor ccw, back motor cw, left motor cw, right motor ccw
#define	DIAGONALFOWARDRIGHT 1	         //move front motor cw, back motor ccw, left motor cw, right motor ccw
#define	DIAGONALBACKWARDLEFT 5         //move front motor ccw, back motor cw, left motor ccw, right motor cw
#define	DIAGONALBACKWARDRIGHT 3        //move front motor cw, back motor ccw, left motor ccw, right motor cw
#define	SPINLEFT 8                     //spin left	move all motors ccw
#define	SPINRIGHT 9                    //spin right move all motors cw

#include "JoystickDriver.c"  //Include file to "handle" the Bluetooth messages.

typedef struct {
	// Keep track what buttons were previously pressed so that
	// we can figure out whether their state changed.
	short old_joy1_Buttons;
	short old_joy2_Buttons;

	// The desired direction is the directory that the user intends the robot
	// to move based on joystick input.
	int desiredDriveDirection;

	// The desired drive speed
	int desiredDriveSpeed;

	// The indicator for whether or not the wrist should automatically move with the arm
	bool autoMode;

	// The following track the current motor speeds and positions
	// of arms.
	int motorLeftSpeed;
	int motorRightSpeed;
	int motorFrontSpeed;
	int motorBackSpeed;
	int armSpeed;
	int armPosition;
	int liftSpeed;
	float wristPosition;
	int tineLockPosition;
	int outriggerSpeed;
} State;

void computeDriveMotorSpeeds(State *state);
void updateAllMotors(State *state);

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                    initializeRobot
//
// Prior to the start of autonomous mode, you may want to perform some initialization on your robot.
// Things that might be performed during initialization include:
//   1. Move motors and servos to a preset position.
//   2. Some sensor types take a short while to reach stable values during which time it is best that
//      robot is not moving. For example, gyro sensor needs a few seconds to obtain the background
//      "bias" value.
//
// In many cases, you may not have to add any code to this function and it will remain "empty".
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

void initializeRobot()
{
	// Set motors to lock when unpowered
	bFloatDuringInactiveMotorPWM = false;

	// Initialize the arm to a known position
	nMotorEncoder[arm] = 0;

	// Initialize the outriggers to a known position
	nMotorEncoder[outrigger] = 0;
	// Set max distance outriggers can extend
	nMotorEncoderTarget[outrigger] = 5000;
	// Sync both outrigger motors
	nSyncedMotors = synchAB;
	nSyncedTurnRatio = 100;

	// Disable joystick driver's diagnostics display to free up nxt screen for our own diagnostics diplay
	disableDiagnosticsDisplay();
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                         Main Task
//
// The following is the main code for the autonomous robot operation. Customize as appropriate for
// your specific robot.
//
// The types of things you might do during the autonomous phase (for the 2008-9 FTC competition)
// are:
//
//   1. Have the robot follow a line on the game field until it reaches one of the puck storage
//      areas.
//   2. Load pucks into the robot from the storage bin.
//   3. Stop the robot and wait for autonomous phase to end.
//
// This simple template does nothing except play a periodic tone every few seconds.
//
// At the end of the autonomous period, the FMS will autonmatically abort (stop) execution of the program.
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

task main()
{
	initializeRobot();

	State desiredState;

	// Initialize everything in the desired state to 0.
	memset(&desiredState, 0, sizeof(desiredState));
	desiredState.wristPosition = 100;
	desiredState.desiredDriveSpeed = DRIVESPEED;

	//waitForStart();   // wait for start of tele-op phase

	while (true)
	{
		computeDriveMotorSpeeds(&desiredState);

		updateAllMotors(&desiredState);
	}
}

void computeDriveMotorSpeeds(State *state)
{
	/*
	DIRECTION PARAMETER: (cw/ccw are determined from perspective of robot's center)
	(cw is positive rotation)
	forward								move left motor cw, right motor ccw
	backward							move left motor ccw, right motor cw
	left									move front motor ccw, back motor cw
	right									move front motor cw, back motor ccw
	diagonal fwd left			move front motor ccw, back motor cw, left motor cw, right motor ccw
	diagonal fwd right		move front motor cw, back motor ccw, left motor cw, right motor ccw
	diagonal bwd left			move front motor ccw, back motor cw, left motor ccw, right motor cw
	diagonal bwd right		move front motor cw, back motor ccw, left motor ccw, right motor cw
	spin left							move all motors ccw
	spin right						move all motors cw
	*/

	switch(state->desiredDriveDirection) {
	case FORWARD: state->motorFrontSpeed = 0;
		state->motorBackSpeed = 0;
		state->motorLeftSpeed = state->desiredDriveSpeed;
		state->motorRightSpeed = -state->desiredDriveSpeed;
		break;
	case BACKWARD: state->motorFrontSpeed = 0;
		state->motorBackSpeed = 0;
		state->motorLeftSpeed = -state->desiredDriveSpeed;
		state->motorRightSpeed = state->desiredDriveSpeed;
		break;
	case LEFT: state->motorFrontSpeed = -state->desiredDriveSpeed;
		state->motorBackSpeed = state->desiredDriveSpeed;
		state->motorLeftSpeed = 0;
		state->motorRightSpeed = 0;
		break;
	case RIGHT: state->motorFrontSpeed = state->desiredDriveSpeed;
		state->motorBackSpeed = -state->desiredDriveSpeed;
		state->motorLeftSpeed = 0;
		state->motorRightSpeed = 0;
		break;
	case DIAGONALFOWARDLEFT: state->motorFrontSpeed = -state->desiredDriveSpeed;
		state->motorBackSpeed = state->desiredDriveSpeed;
		state->motorLeftSpeed = state->desiredDriveSpeed;
		state->motorRightSpeed = -state->desiredDriveSpeed;
		break;
	case DIAGONALFOWARDRIGHT: state->motorFrontSpeed = state->desiredDriveSpeed;
		state->motorBackSpeed = -state->desiredDriveSpeed;
		state->motorLeftSpeed = state->desiredDriveSpeed;
		state->motorRightSpeed = -state->desiredDriveSpeed;
		break;
	case DIAGONALBACKWARDLEFT: state->motorFrontSpeed = -state->desiredDriveSpeed;
		state->motorBackSpeed = state->desiredDriveSpeed;
		state->motorLeftSpeed = -state->desiredDriveSpeed;
		state->motorRightSpeed = state->desiredDriveSpeed;
		break;
	case DIAGONALBACKWARDRIGHT: state->motorFrontSpeed = state->desiredDriveSpeed;
		state->motorBackSpeed = -state->desiredDriveSpeed;
		state->motorLeftSpeed = -state->desiredDriveSpeed;
		state->motorRightSpeed = state->desiredDriveSpeed;
		break;
	case SPINLEFT: state->motorFrontSpeed = -state->desiredDriveSpeed;
		state->motorBackSpeed = -state->desiredDriveSpeed;
		state->motorLeftSpeed = -state->desiredDriveSpeed;
		state->motorRightSpeed = -state->desiredDriveSpeed;
		break;
	case SPINRIGHT:	state->motorFrontSpeed = state->desiredDriveSpeed;
		state->motorBackSpeed = state->desiredDriveSpeed;
		state->motorLeftSpeed = state->desiredDriveSpeed;
		state->motorRightSpeed = state->desiredDriveSpeed;
		break;
	default:	state->motorFrontSpeed = 0;
		state->motorBackSpeed = 0;
		state->motorLeftSpeed = 0;
		state->motorRightSpeed = 0;
	}
}

void updateAllMotors(State *state)
{
	motor[front] = state->motorFrontSpeed;
	motor[back] = state->motorBackSpeed;
	motor[left] = state->motorLeftSpeed;
	motor[right] = state->motorRightSpeed;
	motor[arm] = state->armSpeed;
	motor[lift] = state->liftSpeed;
	motor[outrigger] = state->outriggerSpeed;
	servo[wrist] = state->wristPosition;
	servo[tineHook1] = state->tineLockPosition;
	servo[tineHook2] = state->tineLockPosition;
}
