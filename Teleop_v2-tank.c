#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  HTServo)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Motor,  mtr_S1_C1_1,     rightTread,     tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C1_2,     leftTread,    tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     lift,          tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     lift2,         tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C3_1,     motorH,             tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_2,     motorI,        tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S1_C4_1,    horiz,                tServoStandard)
#pragma config(Servo,  srvo_S1_C4_2,    vert1,                tServoStandard)
#pragma config(Servo,  srvo_S1_C4_3,    vert2,                tServoStandard)
#pragma config(Servo,  srvo_S1_C4_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                           RMRobotics Tele-Operation Mode Code
//
// Program for teleop (remote control) portion of 2012-2013 FTC game: Ring It Up
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

#include "JoystickDriver.c"  //Include file to "handle" the Bluetooth messages.

#define WRISTSPEED .3

typedef struct {
	TJoystick joy;

	short joy1_Buttons_Changed;  // Bit map for the 12 buttons. 1 means that the button changed state
	short joy2_Buttons_Changed;
} UserInput;

typedef struct {
	// Keep track what buttons were previously pressed so that
	// we can figure out whether their state changed.
	short old_joy1_Buttons;
	short old_joy2_Buttons;

	// Keep track of left and right tread speeds
	int leftTreadSpeed;
	int rightTreadSpeed;

	// Keep track of wrist servos' positions
	float horizPos; // (0 - 255)
	float vert1Pos; // (0 - 247)
	float vert2Pos; // (0 - 227)

	// Keep track of lift speed
	int liftSpeed;

} State;

void getLatestInput(State *state, UserInput *input);
void handleDriveInputs(State *state, UserInput *input);
void handleLiftInputs(State *state, UserInput *input);
void handleSpecialButtons(State *state, UserInput *input);
void handleWristInputs(State *state, UserInput *input);
void verifyCommands(State *state);
void updateAllMotors(State *state);
void showDiagnostics(State *state);

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                    initializeRobot
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

void initializeRobot()
{
  servo[horiz] = 0;
  servo[vert2] = 220;
  servo[vert1] = 225;

  // Disable joystick driver's diagnostics display to free up nxt screen for our own diagnostics diplay
	disableDiagnosticsDisplay();

  return;
}


/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                         Main Task
//
// This is the main loop for the Tele-op program.
//
// The current controls to the robot are the following:
//
//               _==7==_                               _==8==_
//              / __5__ \                             / __6__ \
//            +.-'_____'-.---------------------------.-'_____'-.+
//           /   |     |  '.                       .'  |     |   \
//          / ___| /|\ |___ \                     / ___|(Y/4)|___ \
//         / |      |      | ;   __        __    ; |             | ;
//         | | <---   ---> | |  |__|      |__|   | |(X/1)   (B/3)| |
//         | |___   |   ___| ; BACK/9   START/10 ; |___       ___| ;
//         |\    | \|/ |    /  _     ___      _   \    |(A/2)|    /|
//         | \   |_____|  .','" "', |___|  ,'" "', '.  |_____|  .' |
//         |  '-.______.-' /       \ MODE /       \  '-._____.-'   |
//         |               |       |------|       |                |
//         |              /\       /      \       /\               |
//         |             /  '.___.'        '.___.'  \              |
//         |            /                            \             |
//          \          /                              \           /
//           \________/                                \_________/
//
// Controls
//   Controller 1
//     Left Joystick:................Left tread speed (analog control)
//     Right Joystick:...............Right tread speed (analog control)
//   Controller 2
//     A/2:........................Hand left
//     B/3:........................Hand right
//     X/1:........................Hand down
//     Y/4:........................Hand up
//     D-pad (Top hat)
//       Up:.........................Increase hand angle relative to the ground
//       Down:.......................Decrease hand angle relative to the ground
//
// NOTE: ASCII Art adapted from: http://chris.com/ascii/index.php?art=video%20games/other
/////////////////////////////////////////////////////////////////////////////////////////////////////

task main()
{
	initializeRobot();

	// Initialize state values
  State currentState;
  memset(&currentState, 0, sizeof(currentState));
  currentState.vert2Pos = 220;
  currentState.vert1Pos = 225;

  wait1Msec(1000);  //waitForStart();   // wait for start of tele-op phase

  while (true)
  {
  	// Get latest user input
  	UserInput input;
  	getLatestInput(&currentState, &input);

  	// Process user inputs
  	handleDriveInputs(&currentState, &input);
  	handleLiftInputs(&currentState, &input);
  	handleSpecialButtons(&currentState, &input);
  	handleWristInputs(&currentState, &input);

  	// Verify validity/possibility of commands
  	verifyCommands(&currentState);

  	// Execute user inputs
  	updateAllMotors(&currentState);
  	showDiagnostics(&currentState);
  }
}

void getLatestInput(State *state, UserInput *input)
{
	// Get the current joystick position
	getJoystickSettings(joystick);

	// Fill out our input structure
	memcpy(input->joy, joystick, sizeof(TJoystick));

	// Calculate which buttons changed.
	input->joy1_Buttons_Changed = input->joy.joy1_Buttons ^ state->old_joy1_Buttons;
	input->joy2_Buttons_Changed = input->joy.joy2_Buttons ^ state->old_joy2_Buttons;

	// Update state for next time.
	state->old_joy1_Buttons = input->joy.joy1_Buttons;
	state->old_joy2_Buttons = input->joy.joy2_Buttons;
}

int joyButton(short bitmask, int button)
{
	//return 1 or 0 based on whether button in bitmask is pressed or not
	return bitmask & (1 << (button - 1));
}

void handleDriveInputs(State *state, UserInput *input)
{
	if (joyButton(input->joy.joy1_Buttons, 6)) { //left bumper
		state->leftTreadSpeed = -40;
	}
  else if (abs(input->joy.joy1_y2) > 20) { // If left joystick is outside dead zone, move left tread, otherwise stop.
		state->leftTreadSpeed = input->joy.joy1_y2 * (100.0 / 128.0) + 0.5;
  }
	else if (joyButton(input->joy.joy1_Buttons, 8)) {	//left trigger control
		state->leftTreadSpeed = 27;
	} else {
		state->leftTreadSpeed = 0;
	}

	if (joyButton(input->joy.joy1_Buttons, 5)) { //right bumper
		state->rightTreadSpeed = -40;
	}
	else if (abs(input->joy.joy1_y1) > 20) { // If right joystick is outside dead zone, move right tread, otherwise stop.
		state->rightTreadSpeed = input->joy.joy1_y1 * (100.0 / 128.0) + 0.5;
	}
	else if(joyButton(input->joy.joy1_Buttons, 7)) { //right trigger control
		state->rightTreadSpeed = 27;
	} else {
		state->rightTreadSpeed = 0;
	}

}

void handleLiftInputs(State *state, UserInput *input)
{
	if (joyButton(input->joy.joy2_Buttons, 6)) {
		state->liftSpeed = 100;
	} else if (joyButton(input->joy.joy2_Buttons, 8)) {
		state->liftSpeed = -30;
	} else {
		state->liftSpeed = 0;
	}
}

void handleSpecialButtons(State *state, UserInput *input) {
	if (joyButton(input->joy.joy1_Buttons, 2)) {
		state->liftSpeed = 100;
		for (int i = 0; i < 2000; i++) {
			getLatestInput(state, input);
			if (joyButton(input->joy.joy1_Buttons, 4)) {
				break;
			}
			updateAllMotors(state);
			wait1Msec(1);
		}
		state->liftSpeed = 0;
		updateAllMotors(state);
	}
}

void handleWristInputs(State *state, UserInput *input)
{
	// Controls for horizontal servo
	if (joyButton(input->joy.joy2_Buttons, 3)) { //right
		state->horizPos += WRISTSPEED;
	} else if (joyButton(input->joy.joy2_Buttons, 1)) {
		state->horizPos -= WRISTSPEED;
	}

	// Controls for synchronized movement of vertical servos
	//   (keeps the angle of the hand relative to the ground constant)
	if (joyButton(input->joy.joy2_Buttons, 4)) {
		state->vert1Pos -= WRISTSPEED;
		state->vert2Pos -= WRISTSPEED;
	} else if (joyButton(input->joy.joy2_Buttons, 2)) {
		state->vert1Pos += WRISTSPEED;
		state->vert2Pos += WRISTSPEED;
	}

	// Controls for individual movement of 2nd vertical servo
	//   (allows the angle of the hand relative to the ground to be changed)
	if (input->joy.joy2_TopHat == 0) {
		state->vert2Pos += WRISTSPEED;
	} else if (input ->joy.joy2_TopHat == 4) {
		state->vert2Pos -= WRISTSPEED;
	}
}



void verifyCommands(State *state)
{
	// If the projected servo values aren't within the servos' ranges,
	// stay at the servos' current positions.

	// Servo Ranges
	// Horiz Servo: 0 - 255
	// 1st Vert Servo: 0 - 247
	// 2nd Vert Servo: 0 - 227

	if (state->horizPos > 255 || state->horizPos < 0) {
		state->horizPos = ServoValue[horiz];
	}

	if (state->vert1Pos > 225 || state->vert2Pos < 0
	 || state->vert2Pos > 220 || state->vert2Pos < 0) {
		state->vert1Pos = ServoValue[vert1];
		state->vert2Pos = ServoValue[vert2];
	}
}

void updateAllMotors(State *state)
{
	motor[leftTread] = state->leftTreadSpeed;
	motor[rightTread] = state->rightTreadSpeed;
	motor[lift] = state->liftSpeed;
	motor[lift2] = state->liftSpeed;
	servo[horiz] = state->horizPos;
	servo[vert1] = state->vert1Pos;
	servo[vert2] = state->vert2Pos;
}

void showDiagnostics(State *state)
{
	//create label
	string sWristHorizPos = "horiz = ";
	string sWristVert1Pos = "vert1 = ";
	string sWristVert2Pos = "vert2 = ";
	string batteryLevel = "power = ";

	//store variable in a string
	string string1 = state->horizPos;
	string string2 = state->vert1Pos;
	string string3 = state->vert2Pos;
	string string4 = externalBatteryAvg;

	//concat variable with label
	strcat(sWristHorizPos, string1);
	strcat(sWristVert1Pos, string2);
	strcat(sWristVert2Pos, string3);
	strcat(batteryLevel, string4);

	eraseDisplay();

	//display label and value
	nxtDisplayTextLine(1, sWristHorizPos);
	nxtDisplayTextLine(3, sWristVert1Pos);
	nxtDisplayTextLine(5, sWristVert2Pos);
	nxtDisplayTextLine(7, batteryLevel);
}
