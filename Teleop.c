#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  HTServo)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Motor,  mtr_S1_C1_1,     right,         tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     left,          tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     back,          tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     front,         tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_1,     lift,          tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_2,     arm,           tmotorTetrix, PIDControl, encoder)
#pragma config(Servo,  srvo_S1_C4_1,    wrist,                tServoStandard)
#pragma config(Servo,  srvo_S1_C4_2,    servo2,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                           Tele-Operation Mode Code Template
//
// This file contains a template for simplified creation of an tele-op program for an FTC
// competition.
//
// You need to customize two functions with code unique to your specific robot.
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

#include "JoystickDriver.c"  //Include file to "handle" the Bluetooth messages.

#define ARMSPEED 50
#define DRIVESPEED 100
#define LIFTSPEED 100
#define FORWARD 0		                   //move left motor cw, right motor ccw
#define BACKWARD 4		                 //move left motor ccw, right motor cw
#define	LEFT 6 	                       //move front motor ccw, back motor cw
#define	RIGHT 2 	                     //move front motor cw, back motor ccw
#define	DIAGONALFOWARDLEFT 7           //move front motor ccw, back motor cw, left motor cw, right motor ccw
#define	DIAGONALFOWARDRIGHT 1	         //move front motor cw, back motor ccw, left motor cw, right motor ccw
#define	DIAGONALBACKWARDLEFT 5         //move front motor ccw, back motor cw, left motor ccw, right motor cw
#define	DIAGONALBACKWARDRIGHT 3        //move front motor cw, back motor ccw, left motor ccw, right motor cw
#define	SPINLEFT 8                     //spin left	move all motors ccw
#define	SPINRIGHT 9                    //spin right move all motors cw

typedef struct {
	int motorLeftSpeed;
	int motorRightSpeed;
	int motorFrontSpeed;
	int motorBackSpeed;
	int armSpeed;
	int armPosition;
	int liftSpeed;
	int wristPosition;
	bool btnPressed;
	bool autoMode;
} State;

void handleDriveInputs(State *state);
void drive(State *state, int dir);
void handleArmInputs(State *state);
void handleWristInputs(State *state);
void handleLiftInputs(State *state);
void checkState(State *theoreticalState, State *realState);
void updateState(State *state);

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                    initializeRobot
//
// Prior to the start of tele-op mode, you may want to perform some initialization on your robot
// and the variables within your program.
//
// In most cases, you may not have to add any code to this function and it will remain "empty".
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

void initializeRobot()
{
  // Place code here to sinitialize servos to starting positions.
  // Sensors are automatically configured and setup by ROBOTC. They may need a brief time to stabilize.

  return;
}


/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                         Main Task
//
// The following is the main code for the tele-op robot operation. Customize as appropriate for
// your specific robot.
//
// Game controller / joystick information is sent periodically (about every 50 milliseconds) from
// the FMS (Field Management System) to the robot. Most tele-op programs will follow the following
// logic:
//   1. Loop forever repeating the following actions:
//   2. Get the latest game controller / joystick settings that have been received from the PC.
//   3. Perform appropriate actions based on the joystick + buttons settings. This is usually a
//      simple action:
//      *  Joystick values are usually directly translated into power levels for a motor or
//         position of a servo.
//      *  Buttons are usually used to start/stop a motor or cause a servo to move to a specific
//         position.
//   4. Repeat the loop.
//
// Your program needs to continuously loop because you need to continuously respond to changes in
// the game controller settings.
//
// At the end of the tele-op period, the FMS will autonmatically abort (stop) execution of the program.
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

task main()
{
  initializeRobot();

  bFloatDuringInactiveMotorPWM = false; //set motors to lock when unpowered

	State theoreticalState;
	State realState;
	// Initialize everything in the theoretical and current state to 0.
	memset(&theoreticalState, 0, sizeof(theoreticalState));
	memset(&realState, 0, sizeof(realState));

	nMotorEncoder[arm] = 0;

  waitForStart();   // wait for start of tele-op phase

  while (true)
  {
	  ///////////////////////////////////////////////////////////
	  ///////////////////////////////////////////////////////////
	  ////                                                   ////
	  ////      Add your robot specific tele-op code here.   ////
	  ////                                                   ////
	  ///////////////////////////////////////////////////////////
	  ///////////////////////////////////////////////////////////

    // Insert code to have servos and motors respond to joystick and button values.

    // Look in the ROBOTC samples folder for programs that may be similar to what you want to perform.
    // You may be able to find "snippets" of code that are similar to the functions that you want to
    // perform.

		getJoystickSettings(joystick);

		handleDriveInputs(&theoreticalState);
		handleLiftInputs(&theoreticalState);
		handleArmInputs(&theoreticalState);

		checkState(&theoreticalState, &realState);

		updateState(&realState);
  }
}

void handleDriveInputs(State *state)
{
	int dir = -1;

	dir = joystick.joy1_TopHat;
	/*
	I defined the direction constants (FORWARD, BACKWARD, etc) to be the values returned by joy1_TopHat for the corresponding direction.
	For example, joy1_TopHat returns 0 when the tophat is pressed foward, and FORWARD is defined as 0.
	Thus, the above statement gives the same result as the below switch statement:

	switch (joystick.joy1_TopHat) {
		case 0: dir = FORWARD; break;
		case 1: dir = DIAGONALFOWARDRIGHT; break;
		case 2: dir = RIGHT; break;
		case 3: dir = DIAGONALBACKWARDRIGHT; break;
		case 4: dir = BACKWARD; break;
		case 5: dir = DIAGONALBACKWARDLEFT; break;
		case 6: dir = LEFT; break;
		case 7: dir = DIAGONALFOWARDLEFT; break;
		default: dir = -1;
	}
	*/

	if (joy1Btn(1) == 1) {
		dir = SPINLEFT;
	} else if (joy1Btn(3) == 1) {
		dir = SPINRIGHT;
	}

	drive(state, dir);
}

void drive(State *state, int dir)
{
	/*
	DIRECTION PARAMETER: (cw/ccw are determined from perspective of robot's center)
	                     (cw is positive rotation)
	forward								move left motor cw, right motor ccw
	backward							move left motor ccw, right motor cw
	left									move front motor ccw, back motor cw
	right									move front motor cw, back motor ccw
	diagonal fwd left			move front motor ccw, back motor cw, left motor cw, right motor ccw
	diagonal fwd right		move front motor cw, back motor ccw, left motor cw, right motor ccw
	diagonal bwd left			move front motor ccw, back motor cw, left motor ccw, right motor cw
	diagonal bwd right		move front motor cw, back motor ccw, left motor ccw, right motor cw
	spin left							move all motors ccw
	spin right						move all motors cw
	*/

	switch(dir) {
		case FORWARD: state->motorFrontSpeed = 0;
							state->motorBackSpeed = 0;
							state->motorLeftSpeed = DRIVESPEED;
							state->motorRightSpeed = -DRIVESPEED;
							break;
		case BACKWARD: state->motorFrontSpeed = 0;
							state->motorBackSpeed = 0;
							state->motorLeftSpeed = -DRIVESPEED;
							state->motorRightSpeed = DRIVESPEED;
							break;
	  case LEFT: state->motorFrontSpeed = -DRIVESPEED;
							state->motorBackSpeed = DRIVESPEED;
							state->motorLeftSpeed = 0;
							state->motorRightSpeed = 0;
							break;
		case RIGHT: state->motorFrontSpeed = DRIVESPEED;
							state->motorBackSpeed = -DRIVESPEED;
							state->motorLeftSpeed = 0;
							state->motorRightSpeed = 0;
							break;
		case DIAGONALFOWARDLEFT: state->motorFrontSpeed = -DRIVESPEED;
							state->motorBackSpeed = DRIVESPEED;
							state->motorLeftSpeed = DRIVESPEED;
							state->motorRightSpeed = -DRIVESPEED;
							break;
		case DIAGONALFOWARDRIGHT: state->motorFrontSpeed = DRIVESPEED;
							state->motorBackSpeed = -DRIVESPEED;
							state->motorLeftSpeed = DRIVESPEED;
							state->motorRightSpeed = -DRIVESPEED;
							break;
		case DIAGONALBACKWARDLEFT: state->motorFrontSpeed = -DRIVESPEED;
							state->motorBackSpeed = DRIVESPEED;
							state->motorLeftSpeed = -DRIVESPEED;
							state->motorRightSpeed = DRIVESPEED;
							break;
		case DIAGONALBACKWARDRIGHT: state->motorFrontSpeed = DRIVESPEED;
							state->motorBackSpeed = -DRIVESPEED;
							state->motorLeftSpeed = -DRIVESPEED;
							state->motorRightSpeed = DRIVESPEED;
							break;
	  case SPINLEFT: state->motorFrontSpeed = -DRIVESPEED;
							state->motorBackSpeed = -DRIVESPEED;
							state->motorLeftSpeed = -DRIVESPEED;
							state->motorRightSpeed = -DRIVESPEED;
							break;
		case SPINRIGHT:	state->motorFrontSpeed = DRIVESPEED;
							state->motorBackSpeed = DRIVESPEED;
							state->motorLeftSpeed = DRIVESPEED;
							state->motorRightSpeed = DRIVESPEED;
							break;
		default:	state->motorFrontSpeed = 0;
							state->motorBackSpeed = 0;
							state->motorLeftSpeed = 0;
							state->motorRightSpeed = 0;
	}
}

void handleArmInputs(State *state)
{
	// Button 5 to raise arm, button 7 to lower arm
	if(joy1Btn(5) == 1)	{
		state->armSpeed = ARMSPEED;
	}
	else if(joy1Btn(7) == 1) {
		state->armSpeed = -ARMSPEED;
	}
	else {
		state->armSpeed = 0;
	}
}

void handleWristInputs(State *state)
{
	// Detect if button was clicked, not just if it's being pressed. If it was clicked, switch auto mode on/off
	if (joy1Btn(10) == 1 && !state->btnPressed) {
		state->autoMode = !state->autoMode;
		state->btnPressed = true;
		state->armPosition = nMotorEncoder[arm];
	}
	else if (joy1Btn(10) == 0) {
	  state->btnPressed = false;
	}

	// If auto mode on, sync arm and wrist. Else, allow manual control of wrist position.
	//     *synced meaning 1deg up on arm makes wrist go down 1deg so that wrist always meaintains the same orientation to the ground
	if (state->autoMode) {
		state->wristPosition = ServoValue[wrist]-(nMotorEncoder[arm]-state->armPosition)/4; // servo values correspond to degrees, encoder values correspond to 1/4 degrees
		state->armPosition = nMotorEncoder[arm];
	}
	else { // Button 6 to raise wrist, button 8 to lower wrist (if wrist isn't being synced to arm)
		if (joy1Btn(6) == 1 && state->wristPosition <= 254) {
			++state->wristPosition;
		}
		else if (joy1Btn(8) == 1 && state->wristPosition >= 1) {
	  	--state->wristPosition;
		}
	}
}

void handleLiftInputs(State *state)
{
	// joystick 1 forward to raise lift, backward to lower lift
	if(joystick.joy1_y1 >= 20) {
		state->liftSpeed = LIFTSPEED;
	}
	else if(joystick.joy1_y1 <= -20) {
	  state->liftSpeed = -LIFTSPEED;
	}
	else {
	  state->liftSpeed = 0;
	}
}

void checkState(State *theoreticalState, State *realState)
{
	realState = theoreticalState;

	// If theoretical wrist position is outside of the servo's range, change it to the closest value within the servo's range
	// The theoretial value is kept though so that if the wrist is synced with the arm, it'll return to being synced once servo values are back in range
	//     *synced meaning 1deg up on arm makes wrist go down 1deg so that wrist always meaintains the same orientation to the ground
	if(theoreticalState->wristPosition < 0) {
		realState->wristPosition = 0;
	}
	else if(theoreticalState->wristPosition > 255) {
		realState->wristPosition = 255;
	}
}

void updateState(State *state)
{
	motor[front] = state->motorFrontSpeed;
	motor[back] = state->motorBackSpeed;
	motor[left] = state->motorLeftSpeed;
	motor[right] = state->motorRightSpeed;
	motor[arm] = state->armSpeed;
	motor[lift] = state->liftSpeed;
	servo[wrist] = state->wristPosition;
}
