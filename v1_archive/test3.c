#pragma config(Motor,  motorA,          A,             tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorB,          B,             tmotorNXT, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                           RMRobotics Tele-Operation Mode Code
//
// TODO: Fill in description
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

#include "JoystickDriver.c"  //Include file to "handle" the Bluetooth messages.

#define ARMSPEED 50
#define DRIVESPEED 100
#define LIFTSPEED 100
#define FORWARD 0		                   //move left motor cw, right motor ccw
#define BACKWARD 4		                 //move left motor ccw, right motor cw
#define	LEFT 6 	                       //move front motor ccw, back motor cw
#define	RIGHT 2 	                     //move front motor cw, back motor ccw
#define	DIAGONALFOWARDLEFT 7           //move front motor ccw, back motor cw, left motor cw, right motor ccw
#define	DIAGONALFOWARDRIGHT 1	         //move front motor cw, back motor ccw, left motor cw, right motor ccw
#define	DIAGONALBACKWARDLEFT 5         //move front motor ccw, back motor cw, left motor ccw, right motor cw
#define	DIAGONALBACKWARDRIGHT 3        //move front motor cw, back motor ccw, left motor ccw, right motor cw
#define	SPINLEFT 8                     //spin left	move all motors ccw
#define	SPINRIGHT 9                    //spin right move all motors cw

typedef struct {
    //TJoystick joy;

    short joy1_Buttons_Changed;  // Bit map for the 12 buttons. 1 means that the button changed state
    short joy2_Buttons_Changed;
} UserInput;

typedef struct {
    // Keep track what buttons were previously pressed so that
    // we can figure out whether their state changed.
    short old_joy1_Buttons;
    short old_joy2_Buttons;

    // The desired direction is the directory that the user intends the robot
    // to move based on joystick input.
    int desiredDriveDirection;

    bool autoMode;

    // The following track the current motor speeds and positions
    // of arms.
	int motorLeftSpeed;
	int motorRightSpeed;
	int motorFrontSpeed;
	int motorBackSpeed;
	int armSpeed;
	int armPosition;
	int liftSpeed;
	int wristPosition;
} State;

void getLatestInput(State *state, UserInput *input);
void handleDriveInputs(State *state, UserInput *input);
void computeDriveMotorSpeeds(State *state);
void handleArmInputs(State *state, UserInput *input);
void handleWristInputs(State *state, UserInput *input);
void handleLiftInputs(State *state, UserInput *input);
void computeActualState(State *desiredState, State *actualState);
void updateAllMotors(State *state);

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                    initializeRobot
//
/////////////////////////////////////////////////////////////////////////////////////////////////////
void initializeRobot()
{
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                         Main Task
//
// TODO - Write up a little bit about how your program works. You might want to document the
//        how the controls work.
//
// The following is the main code for the tele-op robot operation.
//
// Game controller / joystick information is sent periodically (about every 50 milliseconds) from
// the FMS (Field Management System) to the robot. Most tele-op programs will follow the following
// logic:
//   1. Loop forever repeating the following actions:
//   2. Get the latest game controller / joystick settings that have been received from the PC.
//   3. Perform appropriate actions based on the joystick + buttons settings. This is usually a
//      simple action:
//      *  Joystick values are usually directly translated into power levels for a motor or
//         position of a servo.
//      *  Buttons are usually used to start/stop a motor or cause a servo to move to a specific
//         position.
//   4. Repeat the loop.
//
// Your program needs to continuously loop because you need to continuously respond to changes in
// the game controller settings.
//
// At the end of the tele-op period, the FMS will autonmatically abort (stop) execution of the program.
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

task main()
{
  initializeRobot();

  State actualState;
  State desiredState;
  // Initialize everything in the desired and actual state to 0.
  memset(&actualState, 0, sizeof(actualState));
  memset(&desiredState, 0, sizeof(desiredState));
  desiredState.wristPosition = 100;
  actualState.wristPosition = 100;

  //waitForStart();   // wait for start of tele-op phase

  while (true)
  {
  	getJoystickSettings(joystick);
  	// Wait for the next update from the joystick.
    UserInput input;
    getLatestInput(&desiredState, &input);

    // Process the joystick input
    handleDriveInputs(&desiredState, &input);
    handleLiftInputs(&desiredState, &input);
    handleArmInputs(&desiredState, &input);
    handleWristInputs(&desiredState, &input);

    computeDriveMotorSpeeds(&desiredState);
    computeActualState(&desiredState, &actualState);
    updateAllMotors(&actualState);
  }
}

void getLatestInput(State *state, UserInput *input)
{
    // Get the current joystick position
    //getJoystickSettings(joystick);

    // Fill out our input structure
    //input->joy = joystick;

    // Calculate which buttons changed.
    input->joy1_Buttons_Changed = joystick.joy1_Buttons ^ state->old_joy1_Buttons;
    input->joy2_Buttons_Changed = joystick.joy2_Buttons ^ state->old_joy2_Buttons;

    // Update state for next time.
    state->old_joy1_Buttons = joystick.joy1_Buttons;
    state->old_joy2_Buttons = joystick.joy2_Buttons;
}

int joyButton(short bitmask, int button)
{
    return bitmask & (1 << (button - 1));
}


void handleDriveInputs(State *state, UserInput *input)
{
	int dir = -1;

  short x = joystick.joy1_x2;
  short y = joystick.joy1_y2;
	if (x == 0) x = 1;
	int angle = atan2(y, x);

	if (abs(x) > 10 || abs(y) > 10) {
		if (x > 0) {
			if (angle > 3*PI/8) {
				dir = FORWARD;
			} else if (angle > PI/8) {
				dir = DIAGONALFOWARDRIGHT;
			} else if (angle > -PI/8) {
				dir = RIGHT;
			} else if (angle > -3*PI/8) {
				dir = DIAGONALBACKWARDRIGHT;
			} else {
			  dir = BACKWARD;
			}
		} else {
			if (angle < -3*PI/8){
				dir = FORWARD;
			} else if (angle < -PI/8) {
				dir = DIAGONALFOWARDRIGHT;
			} else if (angle < PI/8) {
				dir = RIGHT;
			} else if (angle < 3*PI/8) {
				dir = DIAGONALBACKWARDRIGHT;
			} else {
			  dir = BACKWARD;
			}
		}
	}

  switch (joystick.joy1_TopHat) {
		case 0: dir = FORWARD; break;
		case 4: dir = BACKWARD; break;
		case 2: dir = SPINRIGHT;
		case 6: dir = SPINLEFT;
	}

    state->desiredDriveDirection = dir;
}

void handleArmInputs(State *state, UserInput *input)
{
    // Button 5 to raise arm, button 7 to lower arm
    if (joyButton(joystick.joy1_Buttons, 5))	{
        state->armSpeed = ARMSPEED;
    }
    else if(joyButton(joystick.joy1_Buttons, 7)) {
        state->armSpeed = -ARMSPEED;
    }
    else {
        state->armSpeed = 0;
    }
}

void handleWristInputs(State *state, UserInput *input)
{
    // Toggle automode if button 10 was clicked (i.e. changed and button down)
    if (joyButton(input->joy1_Buttons_Changed, 10) &&
            joyButton(joystick.joy1_Buttons, 10)) {
        state->autoMode = !state->autoMode;
    }

    // If auto mode on, sync arm and wrist. Else, allow manual control of wrist position.
    //     *synced meaning 1deg up on arm makes wrist go down 1deg so that wrist always meaintains the same orientation to the ground
    if (state->autoMode) {
        PlayTone(500, 1);
    }
    else { // Button 6 to raise wrist, button 8 to lower wrist (if wrist isn't being synced to arm)
        if (joyButton(joystick.joy1_Buttons, 6)) {
          PlayTone(100, 1);
        }
        else if (joyButton(joystick.joy1_Buttons, 8)) {
        	PlayTone(100, 1);
        }
    }
}

void handleLiftInputs(State *state, UserInput *input)
{
    // joystick 1 forward to raise lift, backward to lower lift
    if(joystick.joy1_y1 >= 20) {
        state->liftSpeed = LIFTSPEED;
    }
    else if(joystick.joy1_y1 <= -20) {
      state->liftSpeed = -LIFTSPEED;
    }
    else {
      state->liftSpeed = 0;
    }
}

void computeDriveMotorSpeeds(State *state)
{
	/*
	DIRECTION PARAMETER: (cw/ccw are determined from perspective of robot's center)
	                     (cw is positive rotation)
	forward								move left motor cw, right motor ccw
	backward							move left motor ccw, right motor cw
	left									move front motor ccw, back motor cw
	right									move front motor cw, back motor ccw
	diagonal fwd left			move front motor ccw, back motor cw, left motor cw, right motor ccw
	diagonal fwd right		move front motor cw, back motor ccw, left motor cw, right motor ccw
	diagonal bwd left			move front motor ccw, back motor cw, left motor ccw, right motor cw
	diagonal bwd right		move front motor cw, back motor ccw, left motor ccw, right motor cw
	spin left							move all motors ccw
	spin right						move all motors cw
	*/

    switch(state->desiredDriveDirection) {
		case FORWARD: state->motorFrontSpeed = 0;
							state->motorBackSpeed = 0;
							state->motorLeftSpeed = DRIVESPEED;
							state->motorRightSpeed = -DRIVESPEED;
							break;
		case BACKWARD: state->motorFrontSpeed = 0;
							state->motorBackSpeed = 0;
							state->motorLeftSpeed = -DRIVESPEED;
							state->motorRightSpeed = DRIVESPEED;
							break;
	  case LEFT: state->motorFrontSpeed = -DRIVESPEED;
							state->motorBackSpeed = DRIVESPEED;
							state->motorLeftSpeed = 0;
							state->motorRightSpeed = 0;
							break;
		case RIGHT: state->motorFrontSpeed = DRIVESPEED;
							state->motorBackSpeed = -DRIVESPEED;
							state->motorLeftSpeed = 0;
							state->motorRightSpeed = 0;
							break;
		case DIAGONALFOWARDLEFT: state->motorFrontSpeed = -DRIVESPEED;
							state->motorBackSpeed = DRIVESPEED;
							state->motorLeftSpeed = DRIVESPEED;
							state->motorRightSpeed = -DRIVESPEED;
							break;
		case DIAGONALFOWARDRIGHT: state->motorFrontSpeed = DRIVESPEED;
							state->motorBackSpeed = -DRIVESPEED;
							state->motorLeftSpeed = DRIVESPEED;
							state->motorRightSpeed = -DRIVESPEED;
							break;
		case DIAGONALBACKWARDLEFT: state->motorFrontSpeed = -DRIVESPEED;
							state->motorBackSpeed = DRIVESPEED;
							state->motorLeftSpeed = -DRIVESPEED;
							state->motorRightSpeed = DRIVESPEED;
							break;
		case DIAGONALBACKWARDRIGHT: state->motorFrontSpeed = DRIVESPEED;
							state->motorBackSpeed = -DRIVESPEED;
							state->motorLeftSpeed = -DRIVESPEED;
							state->motorRightSpeed = DRIVESPEED;
							break;
	  case SPINLEFT: state->motorFrontSpeed = -DRIVESPEED;
							state->motorBackSpeed = -DRIVESPEED;
							state->motorLeftSpeed = -DRIVESPEED;
							state->motorRightSpeed = -DRIVESPEED;
							break;
		case SPINRIGHT:	state->motorFrontSpeed = DRIVESPEED;
							state->motorBackSpeed = DRIVESPEED;
							state->motorLeftSpeed = DRIVESPEED;
							state->motorRightSpeed = DRIVESPEED;
							break;
		default:	state->motorFrontSpeed = 0;
							state->motorBackSpeed = 0;
							state->motorLeftSpeed = 0;
							state->motorRightSpeed = 0;
	}
}

void computeActualState(State *desiredState, State *actualState)
{
	actualState->motorLeftSpeed = desiredState->motorLeftSpeed;
	actualState->motorRightSpeed = desiredState->motorRightSpeed;
	actualState->motorFrontSpeed = desiredState->motorFrontSpeed;
  actualState->motorBackSpeed = desiredState->motorBackSpeed;
	actualState->armSpeed = desiredState->armSpeed;
	actualState->liftSpeed = desiredState->liftSpeed;
	actualState->wristPosition = desiredState->wristPosition;
}

void updateAllMotors(State *state)
{
	motor[A] = state->motorFrontSpeed;
	motor[B] = state->motorLeftSpeed;
	//motor[A] = state->armSpeed;
	//motor[B] = state->liftSpeed;
}
