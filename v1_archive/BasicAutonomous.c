#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  HTServo)
#pragma config(Sensor, S2,     color,          sensorCOLORFULL)
#pragma config(Sensor, S3,     touch,          sensorTouch)
#pragma config(Motor,  motorA,          outrigger,     tmotorNXT, PIDControl, reversed, encoder)
#pragma config(Motor,  motorB,          outrigger2,    tmotorNXT, PIDControl, reversed, encoder)
#pragma config(Motor,  motorC,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  mtr_S1_C1_1,     right,         tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     left,          tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     back,          tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     front,         tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_1,     lift,          tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_2,     arm,           tmotorTetrix, PIDControl, encoder)
#pragma config(Servo,  srvo_S1_C4_1,    wrist,                tServoStandard)
#pragma config(Servo,  srvo_S1_C4_2,    tineHook,             tServoStandard)
#pragma config(Servo,  srvo_S1_C4_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                           RM Robotics Autonomous Mode Code
//
// Program for autonomous portion of 2012-2013 FTC game: Ring It Up
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

#include "JoystickDriver.c"  //Include file to "handle" the Bluetooth messages.

#define ARMSPEED 3
#define DRIVESPEED 100
#define LIFTSPEED 100
#define WRISTSPEED .1
#define FORWARD 0		                   //move left motor cw, right motor ccw
#define BACKWARD 4		                 //move left motor ccw, right motor cw
#define	LEFT 6 	                       //move front motor ccw, back motor cw
#define	RIGHT 2 	                     //move front motor cw, back motor ccw
#define	DIAGONALFOWARDLEFT 7           //move front motor ccw, back motor cw, left motor cw, right motor ccw
#define	DIAGONALFOWARDRIGHT 1	         //move front motor cw, back motor ccw, left motor cw, right motor ccw
#define	DIAGONALBACKWARDLEFT 5         //move front motor ccw, back motor cw, left motor ccw, right motor cw
#define	DIAGONALBACKWARDRIGHT 3        //move front motor cw, back motor ccw, left motor ccw, right motor cw
#define	SPINLEFT 8                     //spin left	move all motors ccw
#define	SPINRIGHT 9                    //spin right move all motors cw

typedef struct {
	// The desired direction is the directory that the user intends the robot
	// to move based on joystick input.
	int desiredDriveDirection;

	// The desired drive speed
	int desiredDriveSpeed;

	// The indicator for whether or not the wrist should automatically move with the arm
	bool autoMode;

	// The following track the current motor speeds and positions
	// of arms.
	int motorLeftSpeed;
	int motorRightSpeed;
	int motorFrontSpeed;
	int motorBackSpeed;
	int armSpeed;
	int armPosition;
	int liftSpeed;
	float wristPosition;
	int tineLockPosition;
	int outriggerSpeed;
} State;

void command (State *state, int dir, int driveSpeed, int armSpeed, int wristPos, int liftSpeed, int time);
void computeDriveMotorSpeeds(State *state);
void updateAllMotors(State *state);

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                    initializeRobot
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

void initializeRobot()
{
	// Set motors to lock when unpowered
	bFloatDuringInactiveMotorPWM = false;

	// Initialize the arm to a known position
	nMotorEncoder[arm] = 0;

	// Initialize the outriggers to a known position
	nMotorEncoder[outrigger] = 0;
	// Set max distance outriggers can extend
	nMotorEncoderTarget[outrigger] = 5000;
	// Sync both outrigger motors
	nSyncedMotors = synchAB;
	nSyncedTurnRatio = 100;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                         Main Task
//
// 1. Go forward until robot sees one of the white lines in front of the pegs
// 2. Follow that line until the robot is right in front of the chosen column of pegs
// 3. Deposit pre-loaded ring onto the bottom peg of that column
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

task main()
{
	initializeRobot();

	State desiredState;

	// Initialize everything in the desired state to 0.
	memset(&desiredState, 0, sizeof(desiredState));
	desiredState.wristPosition = 20;
	desiredState.tineLockPosition = 180;

	waitForStart();   // wait for start of autonomous phase

	//command format:
	//command (State *state, int dir, int driveSpeed, int armSpeed, int wristPos, int liftSpeed, int time);

	command(&desiredState, 0, 100, 0, desiredState.wristPosition, 0, 3000);
	//raise lift and release arm
	command(&desiredState, -1, 0, 0, desiredState.wristPosition, 100, 5000);
	command(&desiredState, -1, 0, 0, 200, 0, 1);

}

void command (State *state, int dir, int driveSpeed, int armSpeed, int wristPos, int liftSpeed, int time) {
	state->desiredDriveDirection = dir;
	state->desiredDriveSpeed = driveSpeed;
	state->armSpeed = armSpeed;
	state->wristPosition = wristPos;
	state->liftSpeed = liftSpeed;

	computeDriveMotorSpeeds(state);
	updateAllMotors(state);

	wait1Msec(time);

	state->desiredDriveDirection = -1;
	state->desiredDriveSpeed = 0;
	state->armSpeed = 0;
	state->liftSpeed = 0;
}

void computeDriveMotorSpeeds(State *state)
{
	/*
	DIRECTION PARAMETER: (cw/ccw are determined from perspective of robot's center)
	(cw is positive rotation)
	forward								move left motor cw, right motor ccw
	backward							move left motor ccw, right motor cw
	left									move front motor ccw, back motor cw
	right									move front motor cw, back motor ccw
	diagonal fwd left			move front motor ccw, back motor cw, left motor cw, right motor ccw
	diagonal fwd right		move front motor cw, back motor ccw, left motor cw, right motor ccw
	diagonal bwd left			move front motor ccw, back motor cw, left motor ccw, right motor cw
	diagonal bwd right		move front motor cw, back motor ccw, left motor ccw, right motor cw
	spin left							move all motors ccw
	spin right						move all motors cw
	*/

	switch(state->desiredDriveDirection) {
	case FORWARD: state->motorFrontSpeed = 0;
		state->motorBackSpeed = 0;
		state->motorLeftSpeed = state->desiredDriveSpeed;
		state->motorRightSpeed = -state->desiredDriveSpeed;
		break;
	case BACKWARD: state->motorFrontSpeed = 0;
		state->motorBackSpeed = 0;
		state->motorLeftSpeed = -state->desiredDriveSpeed;
		state->motorRightSpeed = state->desiredDriveSpeed;
		break;
	case LEFT: state->motorFrontSpeed = -state->desiredDriveSpeed;
		state->motorBackSpeed = state->desiredDriveSpeed;
		state->motorLeftSpeed = 0;
		state->motorRightSpeed = 0;
		break;
	case RIGHT: state->motorFrontSpeed = state->desiredDriveSpeed;
		state->motorBackSpeed = -state->desiredDriveSpeed;
		state->motorLeftSpeed = 0;
		state->motorRightSpeed = 0;
		break;
	case DIAGONALFOWARDLEFT: state->motorFrontSpeed = -state->desiredDriveSpeed;
		state->motorBackSpeed = state->desiredDriveSpeed;
		state->motorLeftSpeed = state->desiredDriveSpeed;
		state->motorRightSpeed = -state->desiredDriveSpeed;
		break;
	case DIAGONALFOWARDRIGHT: state->motorFrontSpeed = state->desiredDriveSpeed;
		state->motorBackSpeed = -state->desiredDriveSpeed;
		state->motorLeftSpeed = state->desiredDriveSpeed;
		state->motorRightSpeed = -state->desiredDriveSpeed;
		break;
	case DIAGONALBACKWARDLEFT: state->motorFrontSpeed = -state->desiredDriveSpeed;
		state->motorBackSpeed = state->desiredDriveSpeed;
		state->motorLeftSpeed = -state->desiredDriveSpeed;
		state->motorRightSpeed = state->desiredDriveSpeed;
		break;
	case DIAGONALBACKWARDRIGHT: state->motorFrontSpeed = state->desiredDriveSpeed;
		state->motorBackSpeed = -state->desiredDriveSpeed;
		state->motorLeftSpeed = -state->desiredDriveSpeed;
		state->motorRightSpeed = state->desiredDriveSpeed;
		break;
	case SPINLEFT: state->motorFrontSpeed = -state->desiredDriveSpeed;
		state->motorBackSpeed = -state->desiredDriveSpeed;
		state->motorLeftSpeed = -state->desiredDriveSpeed;
		state->motorRightSpeed = -state->desiredDriveSpeed;
		break;
	case SPINRIGHT:	state->motorFrontSpeed = state->desiredDriveSpeed;
		state->motorBackSpeed = state->desiredDriveSpeed;
		state->motorLeftSpeed = state->desiredDriveSpeed;
		state->motorRightSpeed = state->desiredDriveSpeed;
		break;
	default:	state->motorFrontSpeed = 0;
		state->motorBackSpeed = 0;
		state->motorLeftSpeed = 0;
		state->motorRightSpeed = 0;
	}
}

void updateAllMotors(State *state)
{
	motor[front] = state->motorFrontSpeed;
	motor[back] = state->motorBackSpeed;
	motor[left] = state->motorLeftSpeed;
	motor[right] = state->motorRightSpeed;
	motor[arm] = state->armSpeed;
	motor[lift] = state->liftSpeed;
	motor[outrigger] = state->outriggerSpeed;
	servo[wrist] = state->wristPosition;
	servo[tineHook] = state->tineLockPosition;
}
