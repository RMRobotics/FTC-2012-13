#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  HTServo)
#pragma config(Sensor, S2,     HTGYRO,         sensorAnalogInactive)
#pragma config(Sensor, S3,     HTColor,        sensorI2CCustom)
#pragma config(Sensor, S4,     legoColor,      sensorCOLORFULL)
#pragma config(Motor,  mtr_S1_C1_1,     rightTread,    tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C1_2,     leftTread,     tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     lift,          tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     lift2,         tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C3_1,     motorH,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_2,     motorI,        tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S1_C4_1,    horiz,                tServoStandard)
#pragma config(Servo,  srvo_S1_C4_2,    vert1,                tServoStandard)
#pragma config(Servo,  srvo_S1_C4_3,    vert2,                tServoStandard)
#pragma config(Servo,  srvo_S1_C4_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"  //Include file to "handle" the Bluetooth messages.
#include "hitechnic-gyro.h"

#define WRISTSPEED .3
//AUTONOMOUS VALUES
  /*
  wait1Msec(milliseconds)
	leftTreadSpeed (-100 -> 100)
	rightTreadSpeed (-100 -> 100)

  horizPos (0-243)
  vert1Pos (0-247)
  vert2Pos (0-227)

  up: liftSpeed (100) returnSpeed (10)
  dn: liftSpeed (10)  returnSpeed (100)
*/


#define FORWARD_ONE 3000
#define PAUSE_ONE 250
//TURN 45 LEFT
//PAUSE ONE
#define FORWARD_TWO 1500


typedef struct {
	// Keep track what buttons were previously pressed so that
	// we can figure out whether their state changed.
	short old_joy1_Buttons;
	short old_joy2_Buttons;

	// Keep track of left and right tread speeds
	int leftTreadSpeed;
	int rightTreadSpeed;

	// Keep track of wrist servos' positions
	float horizPos; // (0 - 243)
	float vert1Pos; // (0 - 247)
	float vert2Pos; // (0 - 227)

	// Keep track of lift speed
	int liftSpeed;
	int returnSpeed;

} State;


void verifyCommands(State *state);
void updateAllMotors(State *state);
void showDiagnostics(State *state);

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                    initializeRobot
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

void initializeRobot()
{
  servo[horiz] = 0;
  servo[vert1] = 225;
  servo[vert2] = 220;

  // Disable joystick driver's diagnostics display to free up nxt screen for our own diagnostics diplay
	disableDiagnosticsDisplay();

  return;
}

task main()
{
  initializeRobot();

  // Initialize state values
  State currentState;
  memset(&currentState, 0, sizeof(currentState));
  currentState.vert2Pos = 220;
  currentState.vert1Pos = 225;

	updateAllMotors(&currentState);


  //!START FROM RIGHT SIDE OF WALl BACKWARD


  waitForStart();   // wait for start of AUTONOMOUS phase

	HTGYROstartCal(HTGYRO);


  //drive backwards
	nxtDisplayTextLine(1, "driving backward");
  currentState.leftTreadSpeed = -100;
  currentState.rightTreadSpeed = -100;
  updateAllMotors(&currentState);
  wait1Msec(FORWARD_ONE); //one sec

	nxtDisplayTextLine(1, "pausing");
  currentState.leftTreadSpeed = 0;
  currentState.rightTreadSpeed = 0;
  updateAllMotors(&currentState);
  wait1Msec(PAUSE_ONE);

  //45 degree turn left back
  nxtDisplayTextLine(1, "turning backward left");
	float heading = 0;
	float rotSpeed = 0;
	float angle = 45;
	currentState.leftTreadSpeed = -100;
	currentState.rightTreadSpeed = 100;
	updateAllMotors(&currentState);
	showDiagnostics(&currentState);

	time1[T1] = 0;

	while (heading < angle) {
		while (time1[T1] < 20) {
			wait1Msec(1);
		}

		time1[T1]=0;

		rotSpeed = HTGYROreadRot(HTGYRO);
		if (rotSpeed < 0) {
			rotSpeed = rotSpeed * -1;
		}
		heading += rotSpeed * 0.02;
	}

	nxtDisplayTextLine(1, "pausing");
  currentState.leftTreadSpeed = 0;
  currentState.rightTreadSpeed = 0;
  updateAllMotors(&currentState);
  wait1Msec(PAUSE_ONE);

  //drive backwards
	nxtDisplayTextLine(1, "driving backwards");
  currentState.leftTreadSpeed = -100;
  currentState.rightTreadSpeed = -100;
  updateAllMotors(&currentState);
  wait1Msec(FORWARD_TWO);



  //reset
  memset(&currentState, 0, sizeof(currentState));
  currentState.vert2Pos = 220;
  currentState.vert1Pos = 225;
  updateAllMotors(&currentState);



  // Execute user inputs
  showDiagnostics(&currentState);

}

void verifyCommands(State *state)
{
	// If the projected servo values aren't within the servos' ranges,
	// stay at the servos' current positions.

	// Servo Ranges
	// Horiz Servo: 0 - 243
	// 1st Vert Servo: 0 - 247
	// 2nd Vert Servo: 0 - 227

	if (state->horizPos > 243 || state->horizPos < 0) {
		state->horizPos = ServoValue[horiz];
	}

	if (state->vert1Pos > 247 || state->vert2Pos < 0
	 || state->vert2Pos > 227 || state->vert2Pos < 0) {
		state->vert1Pos = ServoValue[vert1];
		state->vert2Pos = ServoValue[vert2];
	}
}

void updateAllMotors(State *state)
{
	motor[leftTread] = state->leftTreadSpeed;
	motor[rightTread] = state->rightTreadSpeed;
	motor[lift] = state->liftSpeed;
	motor[lift2] = state->liftSpeed;
	servo[horiz] = state->horizPos;
	servo[vert1] = state->vert1Pos;
	servo[vert2] = state->vert2Pos;
}

void showDiagnostics(State *state)
{
	//create label
	string sWristHorizPos = "horiz = ";
	string sWristVert1Pos = "vert1 = ";
	string sWristVert2Pos = "vert2 = ";

	//store variable in a string
	string string1 = state->horizPos;
	string string2 = state->vert1Pos;
	string string3 = state->vert2Pos;

	//concat variable with label
	strcat(sWristHorizPos, string1);
	strcat(sWristVert1Pos, string2);
	strcat(sWristVert2Pos, string3);

	eraseDisplay();

	//display label and value
	nxtDisplayTextLine(1, sWristHorizPos);
	nxtDisplayTextLine(3, sWristVert1Pos);
	nxtDisplayTextLine(5, sWristVert2Pos);
}
